# app/jobs/vrp_job.rb
class VrpJob < ApplicationJob\n  include LogBroadcaster\n  queue_as :default\n\n  def perform(job_id)\n    job = Job.find(job_id)\n\n    job.update!(status: :running, progress: 10)\n    stream_log("Mission ##{job.id} started (solver=\#{job.solver || 'tabu'})")\n\n    # Prepare a payload summary so we can see exactly what weâ€™re sending\n    raw_params = job.params || {}\n    payload = PythonClient.prepare_payload_for_preview(raw_params)\n    loc_count = payload[:locations].is_a?(Array) ? payload[:locations].size : 0\n\n    stream_log("Prepared payload: locations=\#{loc_count}, vehicle_count=\#{payload[:vehicle_count] || 'n/a'}, max_distance=\#{payload[:max_distance] || 'n/a'}")\n\n    begin\n      job.update!(progress: 25)\n      stream_log("Posting to Python serviceâ€¦")\n\n      result = PythonClient.solve_vrp(raw_params)\n
      job.update!(progress: 80)\n      stream_log("Python responded OK. Normalizing resultâ€¦")\n\n      # result should already be normalized to Vrp::Result\n      job.update!(status: :succeeded, progress: 100, result: result)\n      stream_log("Mission ##{job.id} succeeded ðŸŽ‰ total_distance_km=\#{result.metrics&.dig(:total_distance_km)}")\n\n    rescue => e\n      job.update!(status: :failed, progress: 100)\n      stream_log("Python error: \#{e.message}", level: :error)\n\n      # If the exception included an HTTP response body, show a short preview\n      if e.message&.include?("Python service returned")\n        stream_log("Response preview: \#{e.message.split(':', 2)&.last&.truncate(300)}", level: :error)\n      end\n\n      Rails.logger.error("VRP job failed: \#{e.class}: \#{e.message}\n\#{e.backtrace&.first(5)&.join("\n")}")\n    end\n  end\nend